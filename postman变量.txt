postman变量

localhost:本机的环回地址，对应的是127.0.0.1

--变量：
	--如果postman中的api多处使用某一个字符串，并且这个字符串换了环境有可能发生变化，就可以用变量
	--postman中，变量只能是一个字符串
	
	两种变量：
		--环境变量：
			--支持多个测试环境
			--一个环境里面可以配置多个变量
			
			--{{}}  两个花括号，中间加上变量名
		
		--全局变量：
			--某些变量的值，和环境没有关系
			-- {{}}，两个花括号表示使用变量
		环境变量需要指定环境，而全局变量不用指定环境，可以直接使用。
	
postman抓包
	--设置postman
	--设置浏览器
	--如果是https协议的包，用postman抓，很可能抓不到。
	
HTTPS协议的抓包：
	--内容传输的时候是加密的
	--必须提供证书，才能访问https协议的网站
	--如果使用代理，也需要提供信任的证书
	
证书：
	--权威机构颁发
	--声明此网站的真实性
	--无法伪造
	--浏览器缺省信任权威机构的证书
	
Fiddler证书：
	可通过浏览器输入localhost:8888 下载根证书，然后倒入到浏览器的根证书中。
	
手机抓包：
	--手机连接wifi的时候设置代理
	--安装了fiddler的电脑和要抓包的手机，应该是同一个网段，最好是同一台路由器

cookie和session
	--cookie
		一种类型的数据存储。set cookie，要把一些数据存在客户端，存储在客户端所在的电脑上。以后再访问这个网站的时候，会在http请求中把这个数据再发送过来。
		
		
		过程：
		登录：输入用户名和密码
		登陆成功后，产生一些数据，要求客户端存储下来。返回的消息中，有一个字段叫做Set-Cookie，里面可以存储一些信息，都是以键值对的方式存储，比如sessionid。凡是在cookie里面的数据，客户端就会把它存放在一个地方。后续再访问这个网站的时候，HTTP请求就会把以前存在cookie里面的数据一股脑的放在请求消息的头字段里面，就叫cookie，并把cookie中的数据发送给服务端，比如说sessionid.
		这个cookie是由服务端返回的时候，要求写到客户端电脑上的。以后客户端每次向服务器发送请求，都会在头里面带上这个cookie的内容。
		
		--cokkie的作用---存储数据。
		--cookie可以设置有效时间，超过这个时间，就不会再携带了。
		--每次访问，cookie的数据都要传。
		
	session
		--会话
		--每个会话都有一个名字
		--浏览器登录一个web服务，后续的一连串交互，都称为在一个会话中。当用户刚刚登录的时候，服务器就会创建一个session，后续所有的http请求，都属于这个会话
		
		--每一次http请求都是独立的，怎么知道属于同一个会话呢？
			--http服务在认证用户登录之后，会创建一个会话号，这个会话号会记录到数据库里面，返回给客户端，告诉客户端，这次登录的会话号是多少，通过Set-Cookie的方式返回，里面会记录会话号即sessionid。只要是存在coolie里面的数据，后续的所有http请求都会带上它。服务器收到后续的http请求时，到请求头里面查询，里面有sessionid，就到数据库中找，有没有存储这个sessionid，如果有，就是一个有效的session。数据库中不仅仅存储了sessionid，还有对应的其它信息，比如用户名，会话的创建时间，超时时间。通过sessionid，可以查到对应的其它信息。
			
			不同的请求，是通过会话关联起来的。
			
			sessionid，利用了cookie机制来传送消息。sessionid也可以不记录在cookie字段中，写在别的字段中也是可以的。但是cookie是浏览器天生支持的。只要把sessionid放到Set-Cookie字段中，浏览器自动会帮你存到电脑上，不需要做额外的操作。
			
			sessionid是cookie里存储的数据之一，cookie可以存储很多数据。
			
			session标志一次登录。
			
			Application中，可以看到cookie
			
			通过浏览器F12，可以查看到服务器响应消息的头中包含了Set-Cookie字段
			
			
--如果服务器要校验sessionid，该怎么做呢？
	--先用postman发送一次登录消息，从返回消息中把sessionid从Set-Cookie字段中提取出来，后续的请求中，把这个sessionid的值放在cookie字段中。
	
	--教管系统开启sessionid校验：
		backend\project\settings_common
		CHECK_USER_FOR_CALL = True
	改成True，重启服务
	
--session机制的弊端：
	1 sessionid会存储在数据库中，每次向服务端发起一个http请求，服务端都会去数据库查询sessionid是不是存在。但是数据库的操作都是服务端中比较消耗系统性能的。对于网站服务或者手机app的服务端而言，通常系统瓶颈都在数据库服务里面。
	
	2 服务端要存储sessionid，增加了业务的复杂性。当系统的用户非常庞大的时候，数据库可能需要进行水平的扩容，需要增加多个后端数据库节点。这时候当同一个用户发送请求的时候，不知道到哪一个数据库中去查询，就增加了业务的复杂度。
	
	为了解决这些问题，目前比较主流的解决方案是token。
	
	token：
		存储数据的消息串。
		除了包含 数据信息 外，还包含了对这个数据的 验证信息。
		
		类似于身份证是公安机关颁发的，token是系统的业务服务器生成的。里面包含的信息：用户名、用户等级、还有一个防伪标签（HMAC），也叫做验证信息（HMAC）。
		防伪标签是通过一系列的算法产生的一串字符。不同的用户信息，算出来的字符也不一样。
		
		算法本身是公开的，
		HmacFunc（秘钥+data）= HMAC
		
		秘钥：不同公司的秘钥不同，而且其他人看不到这个秘钥
		

接口测试+token的流程：
	用户登录；
	服务端为用户生成了一个token，token中包含了用户信息如用户名，等级，验证信息，不存储在数据库中。验证信息由秘钥产生。这个token在响应消息时返回，也是放在头字段中，通常放在authorization字段中。后续的请求，客户端也会带上这个token。服务端再次收到数据，就会到请求头里面找token的数据，并验证这个数据是否被客户端篡改。例如用户等级由银牌会员改成了钻石会员，服务端收到请求时会对数据重新生成验证信息，发现新生成的与原来的信息不一样，就可以判断出信息被篡改了。
	
	token，验证信息无需查看数据库，有机制保证数据不会被篡改。好处是省去了数据库存储
	
session与token：
	session机制给客户端传递的只是一个sessionid，有效的数据是存在服务端的数据库里的。每次后续的请求来的时候，服务端都要去找，对应的数据是否在数据库中存在，如果存在，说明用户是有效的，再查看用户的级别，有没有资格进行这次操作。真实的数据和用户信息都存储在数据库中。通过sessionid作为一个凭证到数据库中去找，作为一个索引。客户端存储的只是一个id，真正的数据存储在数据库中。
	
	token中传输的就是真实的数据，一直在网络中来回传输。每次都要验证。相比于到数据库中查数据，验证的操作性能速度非常快。只是cpu和内存中运算。
	目前很多api都使用token机制。
	
	如果接口中youtoken，构造请求的时候，需要带上token。认证成功之后，服务端会在http响应中把token返回给客户端。这个字段有的在响应头中，有的在响应消息体中。优点是性能高，不但是单点，水平扩展也很方便。
	
	




		